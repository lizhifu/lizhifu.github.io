---
layout: post
title:  "cas操作"
date:   2017-02-06 21:53:41
categories: java
tags: java  cas
---

* content
{:toc}

CAS，即compare and swap（比较并交换）。  

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。   如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。  
因此CAS操作即读、​修改、写入操作。  




比如地址V处值为a，有两个线程分别为：  

1. CAS（V,a,b）

2. CAS（V,a,c）

此时V处的地址为a，若1先把V处值更新为b，则此时2检测到地址V处值发生变化，则2更新失败。  


## CAS的实现

java的CAS会调用JNI，通过C++调用底层指令实现。  

在多处理器运行时，底层指令会加上lock前缀（即CPU的锁），保证操作的原子性。​  



CPU锁保证原子性：  

1.  处理器自动保证内存操作原子性

    当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。​

2.  使用总线锁保证原子性

总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。​

3.  使用缓存锁保证原子性​

“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效。

​​

## CAS的缺点：
 
### 1. ABA问题​

   即值由A->B->A，CAS会检测到值没有发生变化，并对它进行更新。

   ​解决办法通常为加版本号，每次检测的时候还对版本号进行比较，每次更新后版本号+1。juc包中用类AtomicStampedReference即采用上述思路解决ABA问题。

### 2. 循环时间长，开销大

   CAS自旋，即每条线程都直接先去执行操作，计算完成后检测是否与其他线程存在共享数据竞争，如果没有则让此操作成功，如果存在共享数据竞争则可能不断地重新执行操作和检测，直到成功为止。

### 3. 只能保证一个共享变量的原子操作

   jdk里提供了AtomicReference类来保证引用对象之间的原子性。

