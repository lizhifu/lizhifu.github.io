---
layout: post
title:  "java并发包-lock包"
date:   2017-02-23 22:34:52
categories: java并发
tags: java并发 lock 
---

* content
{:toc}

## Lock接口     

锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。





`Lock接口提供的相对synchronized﻿不具备的主要特性`  

![lock-1]({{"/css/pics/lock/lock-1.png"}})  

`Lock的api`  
![lock-2]({{"/css/pics/lock/lock-2.png"}}) 

## AbstractQueuedSynchronizer（队列同步器）

队列同步器（AQS）:  用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。

同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。  
子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件。

                                                                         ——from《java并发编程的艺术》

在ReentrantLock、ReentrantReadWriteLock和CountDownLatch中，都是在内部定义Sync继承AbstractQueuedSynchronizer来实现。如下图所示：  
![lock-3]({{"/css/pics/lock/lock-3.png"}}) 


因此，可以通过继承AbstractQueuedSynchronizer来自定义所需的锁。

同步器提供的模板方法基本上分为3类：

1.  独占式获取与释放同步状态、

2.  共享式获取与释放同步状态

3.  查询同步队列中的等待线程情况。

共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。  

## ReentrantLock重入锁

 即支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。

 重进入： 是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。需要解决以下两个问题。

 1）线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。

 2）锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。

## ReentrantReadWriteLock读写锁​

ReentrantReadWriteLock： 上述ReentrantLock是排他锁，在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。  

`ReenTranReadWriteLock特性`  
![lock-4]({{"/css/pics/lock/lock-4.png"}})   

ReentrantReadWriteLock实现ReadWriteLock接口，和ReentrantLock没有关系，都是单独的实现。



## StampedLock​
是java8中出现的新型锁，它是一个读写锁的改进，它的思想是读写锁中读不仅不阻塞读，同时也不应该阻塞写。

实现思路：

​在读的时候如果发生了写，则应当重读而不是在读的时候直接阻塞写。

因为在读线程非常多而写线程比较少的情况下，写线程可能发生饥饿现象，也就是因为大量的读线程存在并且读线程都阻塞写线程，因此写线程可能几乎很少被调度成功。当读执行的时候另一个线程执行了写，则读线程发现数据不一致则执行重读即可。所以读写都存在的情况下，使用StampedLock就可以实现一种无障碍操作，即读写之间不会阻塞对方，但是写和写之间还是阻塞的。

StampedLock的实现思想：

在StampedLock中使用了CLH自旋锁，如果发生了读失败，不立刻把读线程挂起，锁当中维护了一个等待线程队列。所有申请锁但是没有成功的线程都会记录到这个队列中，每一个节点（一个节点表示一个线程）保存一个标记位（locked），用于判断当前线程是否已经释放锁。当一个未标记到队列中的线程试图获得锁时，会取得当前等待队列尾部的节点作为其前序节点，并使用类似如下代码（一个空的死循环）判断前序节点是否已经成功的释放了锁。



它对于读/写都提供了四个接口(换成write为写锁)：  

```java  
readLock()                             //获取读锁（阻塞，不响应中断）  
tryReadLock()                          //获取读锁（立即）  
tryReadLock(long time, TimeUnit unit)  //限时获取读锁（响应中断）  
readLockInterruptibly()                //获取读锁（阻塞，响应中断）  
```  








