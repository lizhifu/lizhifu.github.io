---
layout: post
title:  "java虚拟机简述"
date:   2017-02-06 23:22:48
categories: java虚拟机
tags: java虚拟机  
---

* content
{:toc}

当我们运行一个java程序时，会经过如下两个步骤：

1. javac编译器会把java源代码转化成java字节码文件；

2. java虚拟机读取字节码文件，把java的类加载进内存。



因此，对于java虚拟机的掌握，简要来说分如下部分：

1. java编译原理（javac编译器如何把java源码转化成java字节码）​

2. class文件结构（class文件中包含有源码的哪些信息）

3. 虚拟机类加载机制（java虚拟机加载类的步骤，java类的加载器的双亲委派模型）

4. java内存管理（运行时数据区域，java的gc，内存的分配与回收策略）​

   




## java编译原理

javac编译器源码也是java，主要编译步骤如下：

1. 词法分析（将java源文件的字符流转变成对应的Token流）

2. 语法分析（将词法分析器分析的Token流组建成结构化的语法树）

3. 语义分析（进行语义分析，将复杂语法转化成简单语法。 ）

4. 代码生成​​​（生成字节码文件）

其中每一步都需要对上一步得到的结果进行遍历，因此javac编译器采用了访问者的设计模式，使得数据结构和对数据结构的操作进行解耦。



## class文件结构​

java的class文件是一组以8字节为基础的二进制流，数据项多于8位，则按高位在前分割成若干个8位存储​。它的顺序和数量被严格限定，每个字节代表的含义长度都不允许改变。

​每一个java的源文件都会生成对应的class文件，其中包含有魔数，版本号，常量池，访问标志，类、接口索引集合、字段表集合、方法表集合、属性表集合。  
  

## 虚拟机类加载机制  


  每一个class文件对应一个java类，虚拟机加载类过程如下：

  1.  加载（将类的class文件读入内存，并为之创建一个java.lang.class对象）

  2.  验证（检验被加载的类是否有正确的内部结构）

  3.  准备（负责为类的静态Field分配内存，并设置默认初始值）

  4.  解析（将类的二进制数据中的符号应用替换成直接引用）

  5. 初始化（对静态Field进行初始化）

**java的类加载器​**

​一般而言，java类的加载器有如下四类：

1. ​启动类加载器Bootstrap ClassLoader（源码为C++）  

​2. 扩展类加载器 ExtClassLoader  

3. 应用程序类加载器 AppClassLoader  

4. 自定义类加载器 User ClassLoader  

​   在类加载时，遵循自底向上进行检查，上层先加载能加载的，不能加载的由底层        加载的机制为java的双亲委派模型。  

### java内存管理  

### 运行时内存区域  ​

java虚拟机在运行时，内存的数据区域分为:

1. 程序计数器（使线程切换后能恢复到正确位置）

2. java虚拟机栈 （包含局部变量表，操作栈，动态链接，方法出口等）

3. 本地方法栈

4. java堆（用于对象的分配）

5. 方法区（包含虚拟机加载的类信息，常量，静态变量，即时编译器编译后代码等）

6. 直接内存（NIO，基于通道与缓冲区）​
  
### 垃圾收集算法  

1. 标记-清除算法​（基础算法，标记所有需回收对象，标记完成后统一回收。缺点:效率低，空间碎片）

2. 复制算法​（内存分成两块，用完一块将存活的拷到另外一块。）

3. 标记-整理算法（所有存活的对象向一端移动，清理掉边界以外的内存）

4. 分代收集算法（把java堆分成新生代和老年代）

### 垃圾收集器：

​Serial收集器（单线程收集器，使用时暂停其他所有工作线程，使用复制算法）

ParNew收集器​（Serial收集器的多线程版本）

Parallel Scavenge收集器​（达到可控制吞吐量）

Serial Old收集器​（老年代版本，使用标记整理算法）

Parallel Old收集器​（老年代版本，使用标记整理算法）

CMS（Concurrent Mark Sweep）收集器​（获取最短回收停顿时间）

​G1收集器  

>     from 《深入分析java Web》 《深入理解Java虚拟机》​

[点击查看Xmind结构图](http://download.csdn.net/detail/ttyyzn2/9722203) 
